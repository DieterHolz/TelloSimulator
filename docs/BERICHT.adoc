:imagesdir: assets
:sourcedir: TelloSimulator/src/main/java
:toc: macro
:checkedbox: pass:normal[{startsb}&#10004;{endsb}]
:crossedbox: pass:normal[{startsb}&#10006;{endsb}]
:table-caption: Tabelle
:figure-caption: Abbildung
:counter: image-counter: 0
:counter: table-counter: 0
:experimental:

= 20FS_IMVS08: Tello Simulator

[.text-center]
*Implementierung eines Simulators für die Tello Drohne*
[.text-center]
image::fhnw_ht_10mm.jpg[width=400, align="center"]
[.text-center]
IP5 im Studiengang Informatik mit Vertiefung in Design und Management an der Fachhochschule Nordwestschweiz +
v0.1 +
Brugg, 6. Oktober 2020

[.text-center]
*Autoren* +
Daniel Obrist +
Severin Peyer +


[.text-center]
*Auftraggeber* +
Fachhochschule Nordwestschweiz FHNW +
vertreten durch Dieter Holz und Barbara Scheuner +
Bahnhofstrasse 6 +
5210 Windisch

[.text-center]
*Betreuer* +
Dr. Dieter Holz +
Dr. Barbara Scheuner

<<<

:toc-title: Inhaltsverzeichnis
toc::[]

<<<

== Management Summary
An der Fachhochschule Nordwestschweiz (FHNW) wird im Rahmen des Workshop-Moduls 2 im Studiengang Informatik iCompetence die Drohne «Tello EDU» von Ryze Robotics <<telloedu>> (nachfolgend: Tello-Drohne) eingesetzt. Bei der Entwicklung von Applikationen zur Steuerung der Drohne steht pro Team mit vier Mitgliedern nur eine Drohne zur Verfügung. Um diesem Flaschenhals entgegen zu wirken und um Missgeschicke mit der echten Drohne vorzubeugen hat die FHNW einen Simulator in Auftrag gegeben, welcher das Verhalten der Drohne nachahmt.

Dabei soll keine Hardware implementiert werden, um nicht eine zusätzliche Abhängigkeit zu erzeugen. Der Simulator soll die gleichen Befehle wie die Tello-Drohne per UDP-Verbindung entgegennehmen und diese möglichst realitätsgetreu in einer einfachen 3D-Welt abbilden.

Der Simulator wurde mit dem JavaFX-Framework (basierend auf Java) umgesetzt. Dieser beinhaltet eine 3D-Szene, in welcher ein quaderförmiger skalierbarer Raum und ein 3D-Modell der Drohne ersichtlich sind. Ebenfalls sind Steuerungselemente für den Simulator, die wichtigsten Parameter für die Drohne sowie einige Parameter für die Verbindung zwischen dem Simulator und dem Steuerungsprogramm vorhanden. Zusätzlich beinhaltet das Layout ein Log, welches das Testen des Codes vereinfacht. Im Hintergrund werden die empfangenen Kommandos und ihre Parameter auf Korrektheit überprüft und das Verhalten fürs User Interface generiert. Die Lösung erlaubt auf einfache Art und Weise eine Steuerungssoftware für die Tello-Drohne zu testen, ohne dabei physische Hilfsmittel zu benötigen.

Der Simulator konnte so weit entwickelt werden, dass wir empfehlen, diesen im Rahmen des Moduls zu verwenden. Es macht Sinn, die einzelnen Kommandos nochmals durchzutesten und das Verhalten der Tello-Drohne und des Simulators zu vergleichen. So kann sichergestellt werden, dass die Drohnensteuerungsapplikation nach dem Testen mit dem Simulator auch die physische Drohne korrekt steuern kann. Mithilfe dieses Berichts kann der Simulator weiterentwickelt und die noch fehelenden Funktionalitäten implementiert werden.

<<<

== Einleitung
=== Ausgangslage
Im Workshop-Modul 2 / ws2C (Programmieren von Minidrohnen und "intelligente Kleidung") der Fachhochschule Nordwestschweiz (FHNW) wird die Tello EDU von Ryze Robotics <<telloedu>> (nachfolgend: Tello-Drohne) eingesetzt. Dabei werden in Teams von durchschnittlich vier Mitgliedern Applikationen zur Steuerung der Drohne entwickelt. Jedem Team steht dabei eine Tello-Drohne zur Verfügung.

=== Problem
Es hat sich gezeigt, dass die Drohne sehr schnell zu einem Engpass führt, da insbesondere im frühen Entwicklungsstadium viel mit der Drohne experimentiert werden muss. Dadurch verzögert sich der Projektfortschritt. Des Weiteren ist es auch bereits zu mehreren Missgeschicken mit der Drohne gekommen. Beispielsweise wurde vergessen ein 'Stopp'/'Land'-Signal einzubauen, weswegen die Drohne in eine Wand geflogen und kaputt gegangen ist.

=== Anforderungen
Um die beiden Probleme zu minimieren, repsektive eleminieren, soll ein Simulator entwickelt werden, welcher sich möglichst gleich verhält wie die echte Tello-Drohne. Dieser soll rein software-technisch umgesetzt werden, damit nicht wieder die Abhängigkeit von einem technischen Gerät entsteht. Der Simulator muss die Programmierschnittstelle des Tello SDK 2.0 anbieten. Folgende Anforderungen wurden definiert:

* Der Simulator kann Kommandos des Operators entgegennehmen und eine Response senden
* Die virtuelle Drohne setzt alle Control-, Read- und Set-Commands visuell realitätsgetrau um
* Der Simulator kann einen Status auf einem separaten Port an den Operator senden
* Der Simulator kann einen Videostream aus der Sicht der Drohne an den Operator senden
* Error-Handling (ungültige Befehle, ungültige Parameter)

Für das Extended Product, haben wir folgende Kann-Ziele definiert:

* Per UI kann eine Raumgrösse eingegeben werden (LxBxH) und eine Startposition der Drohne (x, y und Start am Boden)
* Der Simulator kann mit mehreren Drohnen (Drohnenschwärme) umgehen

<<<

=== Lösung
Die umgesetzte Lösung für das Problem ist ein einfacher Simulator, basierend auf JavaFX. Die Funktionen sind zu grossen Teilen identisch mit der Tello-Drohne. Die Verbindung und der Datenaustausch zum Simulator ist, analog zur Drohne, über UDP gelöst.

=== Zielpublikum
Der Simulator dient Studierenden, welche mit der Tello-Drohne arbeiten und die Funktionalitäten der physischen Drohne zuerst softwaretechnisch testen möchten. Im Speziellen wurde er für das Modul «ws2C» an der FHNW  entwickelt. Gemäss der Modulbeschreibung <<ws2c-fhnw>> beherrschen die Studierenden die Grundkonzepte der objektorientierten Programmierung.

<<<

== Hauptteil

=== Architektur
Die Software-Architektur des Simulators ist geprägt durch JavaFX-Komponenten im Frontend. Die Logik im Backend besteht hauptsächlich aus den UDP-Schnittstellen und dem Handling der Commands. Die nachfolgenden zwei Kapitel geben einen Überblick der Applikations-Struktur und beschreiben die wichtigsten Klassen.


==== Frontend
Das User-Interface des Simulators ist mit den typischen JavaFX-Bausteinen aufgebaut. Die Benutzerfreundlichkeit wurde
bei der Gestaltung nicht speziell beachtet und hat bestimmt noch ein gewisses Verbesserungspotenzial. Der Fokus des Projekts lag jedoch auf den Grundfunktionalitäten, weswegen nicht viele Ressourcen in die Usability investiert wurden.

===== SimulatorPane
Die SimulatorPane ist die übergeordnete BorderPane, welche alle anderen JavaFX-Nodes enthält. Links befinden sich die SimulatorControls zum Setzen und Beobachten von Simulator- und Drohnen-Parametern. Auf der rechten Seite sind die NetworkControls, welche alle nötigen Informationen zum Verbindungsaufbau mit dem Simulator anzeigen. Unten findet der User eine interaktive LogBox, welche dem Debugging dient. Und in der Mitte befindet sich die Simulator3DScene, in welcher die 3D-Welt und die virtuelle Drohne gerendert werden.

image::tello-simulator-gui-final.png[width=1200, title="Das User Interface (UI) zum Stand des finalen Releases mit SimulatorControls (links), NetworkControls (rechts), LogBox (unten) und Simulator3DScene (mitte).", id="Figure-{counter:image-number}"]

====== SimulatorControls
Diese Komponente zeigt die wichtigsten Parameter der Drohne an. Dazu gehören die X-, Y- und Z-Position sowie die Yaw-, Pitch- und Roll-Werte. Zusätzlich steht ein Reset-Button zur Verfügung, wodurch alle Werte der virtuellen Drohne zurückgesetzt werden. Mit dem Button darunter kann der User ausserdem zwischen Simulator- und Drohnenkamera hin und her wechseln. Ebenfalls befinden sich hier vier Slider zur Konfiguration der Grösse des virtuellen Raums. Ist ein Slider angewählt, können die Werte auch mit den Pfeiltasten eingestellt werden.

====== NetworkControls
Die NetworkControls auf der rechten Seite beinhalten zuoberst den *Start Drone*-Button, mit welchem die virtuelle Drohne ein- und ausgeschaltet
werden kann. Dieser Button repräsentiert in der Funktionsweise den On-Off-Schalter der echten Tello-Drohne. Denn erst nachdem die Tello-Drohne eingeschaltet wurde kann man sich mit ihr verbinden. Analog müss auch die virtuelle Drohne zuerst gestartet werden. Nach dem Betätigen des "Start Drone"-Buttons baut der Simulator die CommandConnection auf und beginnt auf dem entsprechenden Port Kommandos (Command) zu empfangen. Des Weiteren wird eine ensprechende Nachricht in das Log geschrieben, um dem User zu zeigen, dass die Drohne auf Commands wartet.

Unterhalb des Start-Buttons befinden sich Informationen zum Verbindungsaufbau mit dem Simulator. Im Feld *IP Address* steht bei aktiver Interntverbindung die IP-Addresse des Geräts, auf welchem der Simulator gerade läuft. Wenn keine Internetverbindung besteht, kann der Simulator diese Addresse leider nicht ermitteln. Dann steht in diesem Feld standardmässig die Loopback-Addresse 127.0.0.1.

Im Feld *Command Port* wird die Port-Nummer angezeigt, auf welcher der Simulator seinen DatagramSocket zum Empfangen von Commands erstellt hat. Hierhin müssen also von einem Client-Programm die Commands geschickt werden.

Das nächste Feld *State Port* gibt den Port an, mit welchem sich die StateConnection des Simulators für das Versenden des Drohnen-Status verbindet. Auf diesem Port sollte man also den Drohnen-Status empfangen.

====== LogBox
Die LogBox an der Unterseite ist ein mächtiges Tool zum Debuggen. Hier werden sozusagen alle Aktivitäten des Simulators geloggt. Die verschiedenen Log-Level sind dabei farblich unterschiedlich dargestelt. Das Log-Level lässt sich je nach Bedarf einstellen, und die ListView wird entsprchend gefiltert. Ebenfalls lässt sich mit *Show Timestamp* ein Zeitstempel ein- und ausblenden. Der Button *Autoscroll to Tail* scrollt automatisch immer nach unten zum neusten Log-Eintrag.

====== Simulator3DScene
Im Mittelpunkt des UI steht die Simulator3DScene, auf welcher die ganze 3D-Welt inklusive virtueller Drohne gerendert wird. Hierzu verwendt der Simulator eine JavaFX-SubScene, welche in der umschliessenden BorderPane im Zentrum platziert ist. Neben der 3D-Welt und der Drohne befinden sich zwei Kameras in dem SceneGraph der Subscene: einerseits die vom User kontrollierbare SimulatorCamera sowie die an die Drohne fixierte DroneCamera.

Die DroneView ist die Repräsentation der Drohne im 3D-Raum als 3D-Modell. Ihr Modell wird mittels einem FXML Source File geladen, inklusive animierten Rotoren. Die Position und Rotation der DroneView sind dabei einseitig an die entsprechenden Properties des DroneModels im Backend gebunden. Das heisst wenn sich im DroneModel was ändert, wird dies durch die DroneView in der 3D-Welt abgebildet.

Damit der User das Verhalten der virtuellen Drohne optimal beobachten kann, lässt sich die SimulatorCamera mit der linken Maustaste drehen. Der Pivot-Punkt, um welchen sich die Kamera dreht, transformiet sich dabei gleichmässig mit der Drohne. So fliegt die Drohne nicht plötzlich aus dem Sichtfeld. Ebenfalls lässt sich die Kamera mit der rechten Maustaste oder durch Drücken des Mausrads nach links und rechts verschieben, um eine andere Perspektive zu erhalten. Die Zoom-Distanz der Kamera lässt sich durch das Scrollen mit dem Mausrad oder dem Touchpad anpassen. Alle diese Manipulationen (Drehen, Verschieben und Zoom) können durch das Halten der Ctrl- beziehungsweise Shift-Taste präzisiert beziehungsweise verstärkt werden.

[title="Überblick aller Interaktionsmöglichkeiten mit der Simulaotor3Dscene.", id="Table-{counter:table-counter}", options="header"]

|===
|Interaktion |Beschreibung

|kbd:[LeftMouse]
|Rotiert die Kamera

|kbd:[Ctrl+LeftMouse]
|Rotiert die Kamera langsam

|kbd:[Shift+LeftMouse]
|Rotiert die Kamera schnell

|kbd:[RightMouse]
|Bewegt die Kamera nach links/rechts

|kbd:[Ctrl+LeftMouse]
|Bewegt die Kamera langsam nach links/rechts

|kbd:[Shift+LeftMouse]
|Bewegt die Kamera schnell nach links/rechts

|kbd:[Scroll]
|Zoom erhöhen/verringern

|kbd:[Ctrl+Scroll]
|Zoom langsam erhöhen/verringern
|===

==== Backend
Die Netzwerkschnittstelle und die grundlegenden Logiken des Simulators wurden stets unter Berücksichtigung des Verhalten der echten Tello-Drohne implementiert. Als Ausgangslage diente die offizielle Tello SDK 2.0 User Guide <<sdk2.0userguide>> sowie eine Tello-Drohne, welche als Testobjekt verwendet werden konnte. Damit liessen sich Stück für Stück die Logiken der Tello-Drohne rekonstruieren und in den Simulator implementieren. Die aus den Tests mit der Tello-Drohne gewonnenen Erkenntnisse sind ins Kaptiel <<Programmierschnittstelle>> eingeflossen.

Systembedingt mussten auch einige Spezialfälle berücksichtigt werden. Der Simulator kann zum Beispiel im Gegensatz zur echten Drohne kein eigenes Wireless-Netzwerk aufbauen. Aussderem muss der Simulator auch auf dem gleichen Gerät laufen können wie das Client-Programm. Dabei kann es zu Konflikten mit der Port-Belegung kommen. Dies ist unter <<UDP-Schnittstelle>> genauer erlätuert. Bei der Tello-Drohne hat man diese Probleme nicht, da die Drohne immer alle Ports für sich selbst zur Verfügung hat.

Um die zentralen Datenflüsse der Tello-Drohne abzubilden, implementiert der TelloSimulator zwei Threads, welche parallel zu dem Hauptprogramm  laufen: die *CommandConnection* und die *StateConnection*. Die *VideoConnection* als letzter Teil dieser Dreifaltigkeit wurde aus Ressourcengründen nicht umgesetzt.

image::tello-simulator-backend-swimlane-diagram.svg[width=800, title="Ein grober Überblick, wie das Backend des TelloSimulator bezüglich parallel laufender Threads aufgebaut ist.", id="Figure-{counter:image-number}"]

===== CommandConnection
Sobald der Benutzer die virtuelle Drohne einschaltet, wird eine neue Instanz der CommandConnection erstellt und der Thread gestartet. Beim Erstellen des Sockets besteht hierbei eine Eigenheit des Simulators. Der Standard-Port der Tello-Drohne wäre 8889, jedoch wird dieser Port in den meisten Fällen schon durch das ebenfalls lokal laufende Client-Programm belegt sein. Deshalb bindet sich der Simulator-DatagramSocket der CommandConnection bewusst zum Port 8879 anstatt 8889. Danach empfängt der Thread laufend UDP-Pakete auf diesem Socket.

Nach einem initalen `command`-Command wird dann wie bei der echten Tello-Drohe der SDK Mode aktiviert. Ab dann ist die Drohne bereit für andere Commands. Gleichzeitig bewirkt dies die Initierung der StateConnection, welche ab dann regelmässig den Drohnen-Status versendet. 

Alle über die CommandConnection empfangenen Nachrichten werden gewrappt als CommandPackage samt Herkunfts-Addresse und Herkunfts-Port an die CommandHandler-Klasse weitergegeben.


===== StateConnection
Die StateConnection ist ein Stück weniger kompliziert, da sie sich nur mit dem Versenden des Drohnen-Status befassen muss. Nach dem Start durch die CommandConnection schickt die StateConnection asynchron alle 100 ms den Status der Drone im entsprechenden Format an die Addresse, von welcher das erste `command`-Command empfangen wurde. Da auf dem State-Port nichts empfangen werden muss, verwendet der Simulator hier den gleichen Port wie die Tello-Drohne.

===== CommandHandler
Die Aufgabe der CommandHandler-Klasse ist es, mit den verschiedenen Commands umzugehen. Der CommandHandler splittet die über die CommandConnection empfangenen Command-Strings auf und extrahiert die enthaltenen Parameter. Anschliessend wird über ein Switch-Statement jedes Command validiert und zu den entsprechenden Methoden im DroneController weitergeleitet. Kann ein Command nicht erfolgreich validiert werden, wird über den CommandResponseSender eine entprechende Antwort an das Client-Programm versendet.

===== CommandResponseSender
Da der Simulator zu diversen Zeitpunkten und von verschiedensten Klassen aus eine Response schicken können muss, ist der CommandResponseSender als `public final class` implementiert. So ist diese Klasse immer die einzige Quelle aller Responses des Simulators. Die Klasse beinhaltet statische Methoden zum Versenden der Responses. Aufgerufen werden diese z.B. aus dem CommandHandler, wenn ein Command als fehlerhaft validiert wurde, oder auch aus dem DroneController, nachdem die Ausführung vollendet wurde. Versendet werden die Responses über den gleichen DatagramSocket, welcher in der CommandConnection inital erstellt wurde. Dadurch erhält das Client-Programm die Antworten immer von der Addresse wo das erste `command`-Command hingeschickt wurde.

===== DroneController
Diese Klasse steuert die virtuelle Drohne und enthält ihre gesamte Logik. Sie aktualisiert und animiert alle Daten, die in dem DroneModel gespeichert sind, dem sie zugeordnet ist. Die Methoden des DroneControllers führen die Befehle aus, wenn sie vom CommandHandler aufgerufen werden. Ebenfalls sendet der Controller Antworten über den CommandResponseSender an das Client-Programm, sobald ein bestimmtes Command fertig ausgeführt wurde.

===== DroneModel
Dies ist die Model-Klasse, welche das Datenmodell der Tello-Drohne repräsentiert. Die Werte des DroneModels werden nur durch die Logik des DroneControllers verändert und im Frontend durch die an seine Properties gebundene Views dargestellt. Dabei dient das DroneModel als *_single source of truth_* für alle anderen Komponenten, die auf die Parameter der Drohne zugreifen möchten. Dies gewährleistet die Datenintegrität und ermöglicht eine einfachere Skalierbarkeit der Applikation in Zukunft.

<<<

=== UDP-Schnittstelle

Identisch zur Tello-Drohne findet auch beim Simulator die gesamte Kommunikation über das UDP-Netzwerkprotokoll statt. Um den Verbindungsaufbau mit dem Simulator ähnlich wie mit der Tello-Drohne zu gestalten, wurde die Schnittstelle so weit wie möglich gleich gestaltet, wie sie von der Tello-Drohne implementiert wird. Als Grundlage diente hierbei der offizielle Tello SDK 2.0 User Guide <<sdk2.0userguide>>. Des Weiteren wurden eigene Tests mit der Tello-Drohne durchgeführt, welche die teilweise lückenhafte Dokumentation im User Guide ergänzen.

==== Visualisierung der Schnittstellen
In Abbildung 3 ist der Netzwerkaufbau dokumentiert, wenn das Client-Programm (genannt Operator) und der Simulator sich auf dem selben Gerät (gleiche IP) befinden, in Abbildung 4, wenn sie sich auf unterschiedlichen Geräten (andere IPs) befinden. Die genauen Erklärungen zur Schnittstelle des Simulators und der Tello-Drohne sind in den nachfolgenden zwei Kaptieln zu finden.

image::tello-simulator-network-diagram-different-host.png[width=800, title="Netzwerk-Diagramm mit Simulator, Client-Programm (Operator) und Tello-Drohne (Operator und Simulator haben die gleiche IP)", id="Figure-{counter:image-number}"]

image::tello-simulator-network-diagram-same-host.png[width=800, title="Netzwerk-Diagramm mit Simulator, Client-Programm (Operator) und Tello-Drohne (Operator und Simulator haben eine unterschiedliche IP)", id="Figure-{counter:image-number}"]

==== Die UDP-Schnittstelle der Tello-Drohne
Die Schnittstelle der Tello-Drohne als eigenständiges Gerät im Netzwerk ist ziemlich unkompliziert und statisch. Commands werden auf der fixen Adresse 192.168.10.1:8889 empfangen sowie an den gleichen Port des Client-Programms versendet. Der State wird auf Port 8890 geschickt, der Videostream auf Port 11111.

[cols="1,2,2,2", options="header", title="Tello-Drone UDP-Schnittstelle für Commands", id="Table-{counter:table-counter}"]

|===
| Verbindung | IP-Adresse der Drone | Empfängt Pakete auf Socket mit Port | Sendet Pakete statisch an

| Command
| 192.168.10.1
| 8889
| Client-IP:8889

| State
| 192.168.10.1
| -
| Client-IP:8890

| Video
| 192.168.10.1
| -
| Client-IP:11111
|===

==== Die UDP-Schnittstelle des Simulators
Aufgrund der Anforderung, dass der Simulator sowohl vom gleichen Gerät aus als auch von jedem sich im lokalen Netzwerk befindenden Client angesteuert werden können muss, ist seine Schnittstelle leicht unterschiedlich gestaltet.

Denn wenn das Client-Programm sowie der Simulator auf dem gleichen Gerät laufen, führt dies zu Konflikten in der Port-Belegung. Beispielsweise kann der Port 8889 nicht mehr vom Client-Programm verwendet werden, wenn sich der Simulator schon an diesen gebunden hat. Daher bindet der Tello-Simulator seinen DatagramSocket der CommandConnection bewusst zum Port 8879 anstatt 8889. Somit kann der Client weiterhin einen Socket auf 8889 erstellen, wie es von der echten Drohne verlangt wird, ohne vom Simulator blockiert zu werden.

[cols="1,2,2,2", options="header", title="Tello-Simulator UDP-Schnittstelle für Commands", id="Table-{counter:table-counter}"]


|===
| Verbindung | IP-Adresse des Simulators | Empfängt Pakete auf Socket mit Port | Sendet Pakete dynamisch an

| Command
| beliebig \| 127.0.0.1
| 8879
| IP und Port aus empfangenen Paket

| State
| beliebig \| 127.0.0.1
| -
| IP und Port aus empfangenen Paket

| Video
| beliebig \| 127.0.0.1
| -
| (noch nicht implementiert)
|===

Somit verhält sich die Simulator-Schnittstelle ein wenig dynamischer als diejenige der Drohne (Port von welchem das Client-Programm sendet ist beliebig). Trotzdem benötigt es Client-seitig nur zwei kleine Anpassungen, um mit dem Simulator zu funktionieren:

. *Die IP muss von 192.168.10.1 auf die Simulator-IP (ersichtlich im Simulator-UI) eingestellt werden.*
. *Der UDP-Socket des Clients (gebunden an Port 8889) muss sich in der connect-Methode zu 8879 verbinden anstatt 8889.*

****
*Hinweis:* Eine detailliere Anleitung zum Verbindungsaufbau mit dem Simulator inkl. beispielhaftem Java-Code ist im Readme des Projekts sowie im Anhang dieses Berichts zu finden.
****

=== Programmierschnittstelle

In diesem Kapitel wird die Programmierschnittstelle des Simulators beschrieben. Dazu gehören alle Commands, welche vom
Simulator unterstützt werden. Grundsätzlich basiert diese Dokumentation der Commands auf dem Tello SDK 2.0 <<sdk2.0userguide>>. Dank ausführlichen Tests mit der Tello-Drohne beinhaltet die folgende Auflistung aber detailliertere und vollständigere Beschreibungen zu den einzelnen Commands.
****
*Für alle Commands gilt:* Unbekannte oder falsch geschriebene Commands liefern die Antwort 'unknown command:' gefolgt vom gesendeten String. Commands sind dabei case-sensitive, d.h. Gross- und Kleinschriebung muss eingehalten werden.
****

[cols="3,5a,2,^1", options="header", title="Control Commands", id="Table-{counter:table-counter}"]

|===
| Command | Beschreibung | Mögliche Antworten | Simulator

| command
| *Enter SDK mode*. Die Drohne ist ab jetzt via commands steuerbar. Ein zweites command zu senden gibt zwar 'ok' zurück, hat aber keine weiteren Auswirkungen.
| ok / error
|{checkedbox}

| takeoff
| *Auto takeoff*. Startet die Motoren und fliegt 30 cm nach oben. Wird nach dem initialen takeoff ein weiteres takeoff gesendet, wird es ignoriert und die Drohne schickt 'error' als Antwort.
| ok / error
|{checkedbox}

| land
| *Auto landing*. Fliegt nach unten bis der Boden erreicht ist und stoppt anschliessend die Motoren. Schickt 'ok' nach der Landung.
| ok / error
|{checkedbox}

| streamon
| *Enable video stream*. Startet die Video-Übertragung.
| ok / error
|

| streamoff
| *Disable video stream*. Stoppt die Video-Übertragung.
| ok / error
|

| emergency
| *Stops motors immediately*. Stoppt die Motoren, fällt auf den Boden. Sendet weiterhin den Status.

Hinweis: Funktioniert zu jeder Zeit.
| keine Antwort
| {checkedbox}

| up x
| *Ascend to x cm*. _x = 20-500_. Bewegt sich x cm nach oben. Nachdem die Drohne sich wieder stabilisiert hat wird die Antwort 'ok' versendet
| ok / error / out of range
| {checkedbox}

| down x
| *Descend to x cm*. _x = 20-500_ . Bewegt sich x cm nach unten. Nachdem die Drohne sich wieder stabilisiert hat wird die Antwort 'ok' versendet.
| ok / error / out of range
| {checkedbox}

| left x
| *Fly left for x cm*. _x = 20-500_. Bewegt sich x cm nach links. Nachdem die Drohne sich wieder stabilisiert hat wird die Antwort 'ok' versendet.
| ok / error / out of range
| {checkedbox}

| right x
| *Fly right for x cm*. _x = 20-500_. Bewegt sich x cm nach rechts. Nachdem die Drohne sich wieder stabilisiert hat wird die Antwort 'ok' versendet
| ok / error / out of range
| {checkedbox}

| forward x
| *Fly forward for x cm*. _x = 20-500_. Bewegt sich x cm nach vorne. Nachdem die Drohne sich wieder stabilisiert hat wird die Antwort 'ok' versendet.
| ok / error / out of range
| {checkedbox}

| back x
| *Fly backwards for x cm*. _x = 20-500_. Bewegt sich x cm nach hinten. Nachdem die Drohne sich wieder stabilisiert hat wird die Antwort 'ok' versendet.
| ok / error / out of range
| {checkedbox}

| cw x
| *Rotate x degrees clockwise*. _[line-through]##x = 1-360##_. Dreht die Drohne um x Grad im Uhrzeigersinn um seine Yaw-Achse. Der Range Check 1-360 Grad ist zwar in der SDK dokumentiert, wird von der Drohne sowie dem Simulator aber nicht angewandt. Auch negative Werte sind möglich.
| ok / error
| {checkedbox}

| ccw x
| *Rotate x degrees counterclockwise*. _[line-through]##x = 1-360##_. Dreht die Drohne um x Grad im Gegenuhrzeigersinn um seine Yaw-Achse. Der Range Check 1-360 Grad ist zwar in der SDK dokumentiert, wird von der Drohne sowie dem Simulator aber nicht angewandt. Auch negative Werte sind möglich.
| ok / error
| {checkedbox}

| flip x
| *Flip in x direction*. _x = left \| right \| forward \| back_. Führt einen Salto in die angegebene Richtung aus.
| ok / error / out of range
| {checkedbox}

| go x y z speed
| *Fly to x y z at speed (cm/s)*. _x = -500-500, y = -500-500, z = -500-500, speed = 10 - 100_. Fliegt zu den entsprechenden Koordinaten (relativ zur aktuellen Drohnenposition). Achsen: x = Drohnenausrichtung, y = Linker Normalvektor der Drohne, z = Aufwärtsvektor der Drohne.

Hinweis: x-, y- und z-Werte können nicht gleichzeitig zwischen -20 - 20 eingestellt werden.
| ok / error / out of range
| {checkedbox}

| stop
| *Hovers in the air*. Unterbricht die Ausführung eines Commands und stoppt die Drohne an ihrer aktuellen Position.

Hinweis: Funktioniert zu jeder Zeit.
| ok / forced stop / error
| {checkedbox}

| curve x1 y1 z1 x2 y2 z2 speed
| *Fly at a curve according to the two given coordinates at speed (cm/s)*. _x1, x2 = -500-500, y1, y2 = -500-500, z1, z2 = -500-500, speed = 10 - 60_. Mit Hilfe der aktuellen Dronenposition als Punkt (0,0,0) und der beiden gegebenen Punkten (relativ zur aktuellen Drohnenposition) wird ein Kreisbogen im Raum konstruiert. Die Drohne fliegt auf dieser Kurve bis sie am Endpunkt (x2, y2, z2) angelangt ist.

Hinweis 1: Wenn x1, y1 und z1 oder x2, y2 und z2 gleichzeitig zwischen -20 und 20 sind, schickt die Drohne die Antwort 'out of range'.

Hinweis 2: Wenn der Bogenradius nicht innerhalb eines Bereichs von 0,5-10 Metern liegt, schickt die Drohne die Antwort 'error Radius is too large!'.
| ok / error / out of range / error Radius is too large!
| {checkedbox}

| go x y z speed mid
| *Fly to the x y z coordinates of the Mission Pad at speed (cm/s)*. _mid = m1-m8, x = -500-500, y = -500-500, z = -500-500, speed = 10 - 100_. Fliegt zu den entsprechenden Koordinaten (relativ zur aktuellen Drohnenposition). Achsen: x = Drohnenausrichtung, y = Linker Normalvektor der Drohne, z = Aufwärtsvektor der Drohne.

Hinweis: x-, y- und z-Werte können nicht gleichzeitig zwischen -20 - 20 eingestellt werden.
| ok / error / out of range
|

| curve x1 y1 z1 x2 y2 z2 speed mid
| *Fly at a curve according to the two given coordinates of the Mission Pad ID at speed (cm/s)*. _x1, x2 = -500-500, y1, y2 = -500-500, z1, z2 = -500-500, speed = 10 - 60_.

Hinweis 1: Wenn x, y und z gleichzeitig zwischen -20 und 20 sind, schickt die Drohne die Antwort 'out of range'.

Hinweis 2: Wenn der Bogenradius nicht innerhalb eines Bereichs von 0,5-10 Metern liegt, schickt die Drohne die Antwort 'error Radius is too large!'.
| ok / error / out of range / error Radius is too large!
|

| jump x y z speed yaw mid1 mid2
| *Fly to coordinates x, y and z of Mission Pad 1, and recognize coordinates 0, 0, z of Mission Pad 2 and rotate to the yaw value*. _mid = m1-m8, x = -500-500, y = -500-500, z = -500-500, speed = 10 - 100 (cm/s)_.

Hinweis 1: Wenn x, y und z gleichzeitig zwischen -20 und 20 sind, schickt die Drohne die Antwort 'out of range'.
| ok / error / out of range
|
|===

[cols="3,5a,2,^1", options="header", title="Set Commands", id="Table-{counter:table-counter}"]

|===
| Command | Beschreibung | Mögliche Antwort | Simulator

| speed x
| *Set speed to x cm/s*. _x = 10-100_. Setzt die Speed-Variable der drohne auf den entsprechenden Wert.
| ok / error
| {checkedbox}

| rc a b c d
| *Set remote controller control via four channels*. _a = left/right (-100-100), b = forward/backward (-100-100), c = up/down (-100-100), d = yaw (-100-100)_. Setzt die Bewegungsgeschwindigkeiten in cm/s in die ensprechende Richtung. Die Werte sind unabhängig von der gesetzten speed-Variable auf der Drohne.

Hinweis 1: Funktioniert zu jeder Zeit und schickt kein ok.

Hinweis 2: Wenn während einer Sekunde nur 20 nach vorne gegeben werden, reicht das meistens noch nicht aus, um die Drohne zu bewegen. Es braucht mind 30 in eine Richtung während zwei Sekunden, um die Drohne überhaupt aus dem "Gleichgewicht" zu bringen.
| out of range
| {checkedbox}

| wifi ssid pass
| *Set Wi-Fi password*. _ssid = updated Wi-Fi name, pass = updated Wi-Fi password_.
| ok / error
| {checkedbox}

| mon
| *Enable mission pad detection (both forward and downward detection)*.
| ok / error
|

| moff
| *Disable mission pad detection*.
| ok / error
|

| mdirection x
| *Change mission pad detection mode*. _x = 0/1/2, 0 = Enable downward detection only, 1 = Enable forward detection only, 2 = Enable both forward and downward detection_.
| ok / error
|

| ap ssid pass
| *Set the Tello to station mode, and connect to a new access point wit the access point's ssid and password*.  _ssid = updated Wi-Fi name, pass = updated Wi-Fi password_.
| ok / error
|

|===

[cols="3,5a,2,^1", options="header", title="Read Commands", id="Table-{counter:table-counter}"]

|===
| Command | Beschreibung | Mögliche Antwort | Simulator

| speed?
| *Obtain current speed (cm/s)*. Gibt den aktuell gesetzten Wert der speed-Variable zurück.
| x = 10-100 +
z.B. `*100.0\r\n*`
| {checkedbox}

| battery?
| *Obtain current battery percentage*. Gibt den aktuellen Batterieladestand zurück.
| x = 0-100 +
z.B. `*76\r\n*`
| {checkedbox}

| time?
| *Obtain current flight time*. Gibt zurück, wie lange die Drohne bereits geflogen ist, seit sie eingeschaltet wurde (in Sekunden). Wenn die Drohne nach der Landung also nicht ausgeschaltet und wieder takeoff gesendet wird, wird die Zeit einfach aufsummiert.
| z.B. `*24s\r\n*`
| {checkedbox}

| wifi?
| *Obtain Wi-Fi SNR*. Gibt das Wi-Fi Signal-to-Noise Ratio zurück. Hardcoded `90` für den Simulator
| z.B. `*90\r\n*`
| {checkedbox}

| sdk?
| *Obtain the Tello SDK version*. Gibt die SDK Version zurück. Z.B. (Tello SDK 2.0) = `20` für den Simulator
| z.B. `*20\r\n*`
| {checkedbox}

| sn?
| *Obtain the Tello serial number*. Gibt die Seriennummer der Drohne zurück.
| z.B. `*0TQDG3UEDBSP12*`
| {checkedbox}

|===
****
*Hinweis:* Antworten von Read Commands sowie der Status der Drone enthalten teilweise new line characters `*\r\n*`.
****

=== Weitere Eigenschaften der Tello-API
Durch ausführliche Tests mit der Tello-Drohne konnten ausserdem folgende besondere Eigenschaften der Tello-API beobachtet werden:

* Es gibt Commands die ein 'ok' zurückschicken, aber auch *"Fire and Forget"-Commands* wie z.B. das rc-Command, welches zu jedem Zeitpunkt von der Drohne ausgeführt wird und keine Antwort schickt.

* Commands werden von der Drohne *nicht gequeued*. Das heisst das Client-Programm muss entsprechend programmiert werden, damit es der Drohne das nächste Command zum passenden Zeitpunkt schickt. Kommt ein Command während ein vorhergehendes noch nicht fertig ausgeführt wurde, dann wird die Antwort *"error Not joystick"* geschickt. Ausnahmen hierzu sind die rc-, stop- und emergency-Commands, welche zu jeder Zeit funktionieren.

* Mitgeschickte *Parameter der Commands können nicht "genullt"* werden, müssen also immer vorhanden sein. Sonst wird das Command nicht erkannt.

* Die Tello-Drohne beginnt mit dem Senden des Status erst nachdem sie *das erste command-Command* erhalten hat.

* Parameter mit *Kommastellen* wie z.B. forward '35.234234' oder 'cw 35.23453' werden von der Drohne ausgeführt.

* Wird nach dem land-Command ein weiteres Control-Command geschickt, welches laufende Motoren benötigt, kommt *"error Motor stop"* als Antwort zurück.

* Mit dem rc-Command gesetzte Werte bleiben **auch nach der Landung noch aktiv**. Eine Landung setzt die rc-Werte also nicht zurück und müssen vor einem erneuten Start idealerweise manuell mit einem erneuten Befehl "rc(0,0,0,0)" zurückgesetzt werden.


=== Usability Testing
Dieses Kapitel beschreibt im Speziellen die Erkenntnisse, welche aus einem Usability Testing gewonnen werden konnten. Des Weiteren wird die Vorgehensweise des Testings kurz erläutert. Das Testkonzept, das Tesatskript, die Testprotokolle sowie die Auswertung sind im Anhang zu finden.
Das Testing wurde auf dem Commit e63f7657acbb2ce787390f7302206a44baecf067 durchgeführt, die Ansicht des GUIs wird in Abbildung 5 gezeigt.

image::tello-simulator-gui-stand-usability-testing.png[width=498, title="GUI zum Stand des Usability Testings", id="Figure-{counter:image-number}"]

==== Vorgehensweise
Um eine unkomplizierte Inbetriebnahme sowie eine einfache Handhabung des Simulators zu gewährleisten, wurde ein Usability Testing durchgeführt.

Das Testing wurde in die folgenden drei Abschnitte unterteilt: «Installation», «Konfiguration des Operators» und «Anwendung TelloSimulator», diese sind im Testkonept im Anhang etwas genauer beschrieben. Per Videotelefonie wurde das Testing mit vier iCompetence-Studierenden der FHNW (2./3. Semester) durchgeführt. Dabei wurde eine Aufgabenstellung per Chat abgegeben und der Proband versuchte die Aufgabe ohne Hilfe des Moderierenden zu lösen. Der Moderierende konnte bei Problemen eingreifen, der Beobachtende notierte die wichtigsten Verhaltensweisen und Aussagen des Probanden. Zusätzlich wurde das Meeting aufgezeichnet, um wichtige Abschnitte nachgehend noch detaillierter zu dokumentieren.

Anschliessend wurden die wichtigsten Erkenntnisse in die folgenden Kategorien unterteilt: «negative Aussagen / beobachtete Probleme», «positive Aussagen» und «Tipps». Diese wurden nach Thema gruppiert. Pro Thema wurde ein Verbesserungsvorschlag definiert und ins Backlog aufgenommen.

==== Erkenntnisse
Durch das Usability Testing konnten die folgenden Erkenntnisse gewonnen werden. Dies ist nur ein Auszug der Wichtigsten, genauere Details sind im Anhang zu finden.

*Installationsanleitung*

** weniger Beschreibungen, warum etwas gemacht wird, dafür genauere Anweisungen
** Probleme, welche auftreten können, in einen Troubleshooting-Abschnitt extrahieren

*Simulator*

** visuelle Orientierung im Raum ist sehr wichtig, um zu sehen, ob die Drohne sich wie gewünscht verhält
*** Schatten einbauen
*** Kameraposition überdenken
*** Drohne als 3D-Model implementieren oder mindestens ein Pfeil auf dem Quader einblenden, damit die Blickrichtung der Drohne klar ist
** Drohne/Simulator muss auch wieder ausgeschaltet werden können
** GUI ist noch nicht sehr strukturiert (schwierig, wichtige Infos zu finden

<<<

== Fazit
Um das Projekt zusammenzufassen und darüber zu reflektieren werden in diesem abschliessenden Kapitel nochmals alle anfangs definierten Anforderungen betrachtet. Ebenfalls sind angetroffene Probleme, gewonnene Erkenntnisse sowie mögliche Weiterentwicklungen der Software festgehalten.

=== Erfüllung der Anforderungen

Eine der wohl zentralsten Anforderungen war das *Entgegennehmen von Commands sowie das Versenden von Responses* via UDP. Deshalb wurde bereits zu Projektbeginn der Fokus auf die Entwicklung dieser Schnittstelle gelegt. So konnte bereits vor MVP-Release eine solide Basis für das Backend gebaut werden, auf welcher auch der finale Release noch beruht.

Das eng mit der ersten Anforderung zusammenhängende *Versenden des Status* gestaltete sich dank der guten Vorabeit mit der CommandConnection entsprechend leicht.

Auch das Umsetzen aller Control-, Read- und Set-Commands konnte bis auf die Mission Pad Detection erfüllt werden. Obwohl beim Ausdruck "realitätsgetreu" wohl gewisse Einschränkungen gemacht wurden (keine Simulation von Schwerkraft, Wind und weiteren komplexen Faktoren) verhält sich die virtuelle Drohne grösstenteils wie die echte Tello-Drohne.

Wo der Simulator ebenfalls glänzt ist das *Error-Handling* von Commands sowie das ganze Logging der Applikation. Mittels Tests mit der echten Tello-Drohne und dem Auslesen des Netzwerk-Verkehrs konnten viele Erkenntnisse bezüglich dem Error-Handling der Drohne gewonnen werden. Diese gingen über die öffentlich zugängliche Tello SDK 2.0 Dokumentation hinaus und halfen dabei, ein möglichst ähnliches Error-Handling zu programmieren. Alle Commands und Parameter werden durch den Simulator validiert und auf das im UI integrierte Log ausgegeben. Dies bietet eine Unterstützung beim Debugging.

Die *Raumgrösse* kann via Slider eingestellt werden. Die Startposition kann via Reset-Button zurückgesetzt werden.

Leider erwies sich das *Versenden des Video-Feeds* als komplizierter als erwartet. Es wurde zwar eine funktionsfähige Videopublisher-Klasse implementiert, welche den Webcam-Feed via UDP überträgt. Die Video-Schnittstelle wurde dabei mittels H.264-Encoding umgesetzt, analog zu derjenigen der Tello-Drohne. Jedoch war es schlussendlich mangels Wissens und Ressourcen nicht möglich, die Funktionalität auf das Versenden der JavaFX-Scene-Snapshots anzuwenden. Aus diesem Grund wurde die Priorität dieser Anforderung nach unten korrigiert und der Task ins Backlog verschoben.

Die Anforderung, mit *Dronhnen-Schwärmen* umzugehen, konnte leider ebenfalls noch nicht angegangen werden. Trotzdem wurde bei der Gestaltung der Software-Architektur darauf geachtet, dass die Applikation skalierbar ist. Durch die Entkopplung von CommandHandler, DroneController und DroneModel könnten theoretisch vom CommandHandler aus auch mehrere DroneModels geupdated werden. Auch vonseiten View wäre für die Anzeige mehrerer DroneViews keine grössere Veränderung nötig.

=== Wahl der Programmiersprache
Zusammen mit unseren Betreuenden haben wir uns am Anfang des Projekts für das JavaFX-Framework entschieden. Der Hauptgrund dafür war das Vorwissen der Betreuenden und uns Studierenden. Der grosse Vorteil dabei war, dass wir sehr schnell mit dem Programmieren loslegen konnten und uns nicht zuerst in eine neue Sprache eindenken mussten. Als Nachteil betrachten wir, dass das Framework nicht wirklich auf 3D ausgelegt ist. Im Nachhinein würden wir uns aber wieder dafür entscheiden.

=== Mögliche Weiterentwicklungen

Obwohl der Simulator in seinem jetzigen Zustand die Grundanforderungen abdeckt, gibt es noch diverse Funktionen,
die aus Ressourcengründen im Backlog des Projekts geblieben sind. Dazu gehören die im vorangehenden Abschnitt beschriebenen Funktionen des Video-Streams sowie der Drohnen-Schwärme. Zusätzlich wurden während der Entwicklung und auch im Testing diverse zusätzliche Weiterentwicklungen disskutiert;


==== Verbesserungen Usability

** *Schatten der Drohne generieren und anzeigen:* Dadurch würde der Abstand zum Boden und die Position der Drohne im Raum noch besser ersichtlich.
** *Simulator als Fullscreen und die Simulator Controls als darüberliegende Ebene darstellen:* So würde der Fokus noch mehr auf der Simulation liegen und der Betrachtende fühlt sich als Teil des 3D-Raums.
** *Simulator Controls als Custom Control gestalten:* Würden die Simulator Controls (x/y/z-Positon, Yaw/Pitch-Roll-Drehung, Reset-Button...) als Custom Control gestaltet, hälfe dies die Bedeutung und die Funktion intuitiver zu erkennen.
** *Log und Network Controls ein- und ausblendbar machen:* Dadurch kann die 3D-Simulation bei Bedarf vergrössert und besser fokussiert werden.
** *Button, um das Log zu leeren:* Dies würde helfen, einfacher zu debuggen, da es übersichtlicher wird.
** *Startposition der Drohne im Raum festlegen:* Trägt zu einer noch realistischeren Funktionsweise des Simulators bei. Dies hilft bei Testings zu erkennen, ob die Drohne beispielsweise in eine Wand fliegt.

==== Flugverhalten realistischer gestalten

** Ausbalancieren nach einem ausgeführten Command
** Flugverhalten bei Flips (nicht um eigene Achse drehen, sondern als kleiner «Kreis»)
** Beschleunigung und Geschwindigkeit exakter erfassen

<<<

== Danksagung
Gerne möchten wir uns bei den folgenden Personen bedanken:

Dank einem kurzen Pausengespräch ist es überhaupt erst dazu gekommen, dass Dr. Dieter Holz diese Arbeit im Namen der FHNW eingereicht hat. Wir freuen uns, dass er ein Projekt auf die Beine gestellt hat, welches zu unseren Interessen und Fähigkeiten passt.

Herzlichen Dank an unsere Betreuer*innen, Dr. Barbara Scheuner und Dr. Dieter Holz für die stete Unterstützung und die konstruktiven Gespräche während der Projektarbeit.

Ebenfalls möchten wir uns bei den Probanden des Usability Testings bedanken. Wir konnten dadurch wertvolles Feedback einholen und den Simulator erheblich weiterentwickeln.

<<<

== Referenzen
=== Literaturverzeichnis
[bibliography]

** [[[telloedu,1]]] https://www.ryzerobotics.com/tello-edu +
** [[[ws2c-fhnw,2]]] https://www.fhnw.ch/de/studium/module/9052760 +
** [[[sdk2.0userguide,3]]] https://dl-cdn.ryzerobotics.com/downloads/Tello/Tello%20SDK%202.0%20User%20Guide.pdf +

=== Abbildungsverzeichnis

** *Abbildung 1* <<Figure-1>>
** *Abbildung 2* <<Figure-2>>
** *Abbildung 3* <<Figure-3>>
** *Abbildung 4* <<Figure-4>>
** *Abbildung 5* <<Figure-5>>

=== Tabellenverzeichnis

** *Tabelle 1* <<Table-1>>
** *Tabelle 2* <<Table-2>>
** *Tabelle 3* <<Table-3>>
** *Tabelle 4* <<Table-4>>
** *Tabelle 5* <<Table-5>>
** *Tabelle 6* <<Table-6>>

<<<

== Ehrlichkeitserklärung
Hiermit erklären wir, die vorliegende Projektarbeit selbstständig, ohne Hilfe Dritter und nur unter Benutzung der angegebenen Quellen verfasst zu haben.

Schlieren, 29.11.2020

image::signature_DO.png[width=200]

Daniel Obrist

Schaffhausen, 29.11.2020

image::signature_SP.png[width=200]

Severin Peyer

<<<

== Anhang
[appendix]
=== link:SETUP.adoc[Installationsanleitung Tello Simulator]
[appendix]
=== link:usability-testing-testkonzept.pdf[Usability-Testkonzept]
[appendix]
=== link:usability-testing-testskript.pdf[Usability-Testskript]
[appendix]
=== Testprotokolle
link:usability-testing-testprotokoll-testperson01.pdf[Testskript Testperson 01]

link:usability-testing-testprotokoll-testperson02.pdf[Testskript Testperson 02]
[appendix]
=== Auswertung Usability Testing
link:assets/usability-testing-teil1-installation.jpg[Auswertung Usability Testing Teil 1 - Installation Simulator]

link:assets/usability-testing-teil2-operator.jpg[Auswertung Usability Testing Teil 2 - Einrichtung Operator]

link:assets/usability-testing-teil3-simulator.jpg[Auswertung Usability Testing Teil 3 - Anwendung Simulator]
